#ifndef RTFF_MIXING_FILTER_H_
#define RTFF_MIXING_FILTER_H_

#include <cstdint>

#include <system_error>
#include <memory>
#include <vector>
#include <complex>

#include "rtff/buffer/waveform.h"
#include "rtff/buffer/block.h"
#include "rtff/fft/window_type.h"

namespace rtff {

class MultichannelOverlapRingBuffer;
class MultichannelRingBuffer;
class Analyzer;

class MixingFilter {
public:
  /**
   * @param input_count: the number of input signals
   * @param output_count: the number of output signals
   */
  MixingFilter(uint8_t input_count, uint8_t output_count);
  virtual ~MixingFilter();

  /**
   * @brief Initialize the filter with the default Hamming window
   * @param channel_count: the number of channel of the input signal
   * @param fft_size: the length in samples of the fourier transform window.
   * @param overlap: the number of samples that will be kept between each
   * window.
   * @param err: an error code that gets set if something goes wrong
   */
  void Init(uint8_t channel_count, uint32_t fft_size, uint32_t overlap,
            std::error_code &err);

  /**
   * @brief Initialize the filter
   * @param channel_count: the number of channel of the input signal
   * @param fft_size: the length in samples of the fourier transform window.
   * @param overlap: the number of samples that will be kept between each
   * window.
   * @param windows_type: type of analysis and synthesis window for FFT, default
   * to Hamming to ensure backward compatibility
   * @param err: an error code that gets set if something goes wrong
   */
  void Init(uint8_t channel_count, uint32_t fft_size, uint32_t overlap,
            fft_window::Type windows_type, std::error_code &err);

  /**
   * @brief Initialize the filter with default stft parameters
   * @param channel_count: the number of channel of the input signal
   * @param err: an error code that gets set if something goes wrong
   */
  void Init(uint8_t channel_count, std::error_code &err);

  /**
   * @brief define the block size
   * @note the block size correspond to the number of frames contained in each
   * AudioBuffer sent to filter using the ProcessBlock function
   * @param value: the block size
   */
  void set_block_size(uint32_t value);

  /**
   * @brief Write a block of raw audio data to the filter
   * @note the buffer should have the same channel_count as its filter and the
   * frame_number
   * should be equal to the filter block_size
   * @param buffer: the input data
   */
  void Write(const Waveform *buffer);

  /**
   * @brief Write a block of raw audio data to the filter
   * @note the buffer should have the same channel_count as its filter and the
   * frame_number
   * should be equal to the filter block_size
   * @param buffer: the input data
   */
  void Read(Waveform *buffer);

  /**
   * @brief Acccess the number of frame of latency generated by the filter
   * @note Due to fourier transform computation, a filter most usually creates
   * latency. It depends on the block size, overlap and fft size.
   * @return The latency generated by the filter in frames.
   */
  virtual uint32_t FrameLatency() const;

  /**
   * @return the fft size in samples
   */
  uint32_t fft_size() const;
  /**
   * @return the overlap in samples
   */
  uint32_t overlap() const;
  /**
   * @return the windows type
   */
  fft_window::Type windows_type() const;
  /**
   * @return the hop size in sample
   */
  uint32_t hop_size() const;
  /**
   * @return the window size in samples
   * @note this value will be the same as the fft size
   */
  uint32_t window_size() const;
  /**
   * @return the block size
   * @see set_block_size
   */
  uint32_t block_size() const;
  /**
   * @return the number of channel of the input signal
   */
  uint8_t channel_count() const;

protected:
  using TransformedBlock = Block<std::complex<float>>;
  using Input = const std::vector<const TransformedBlock *> &;
  using Output = const std::vector<TransformedBlock *> &;

  uint8_t input_count_;
  uint8_t output_count_;

  /**
   * @brief function called at the end of the initialization process.
   * @note Override this to initialize custom member in child classes
   */
  virtual void PrepareToPlay();

  /**
   * @brief Process a frequential buffer.
   * @note that function is called by the ProcessBlock function. It shouldn't be
   * called on its own
   * Override this function to design your filter
   */
  virtual void
  ProcessTransformedBlock(const std::vector<const TransformedBlock *> &input,
                          const std::vector<TransformedBlock *> &output) = 0;

private:
  void InitBuffers();

  uint32_t fft_size_;
  uint32_t overlap_;
  fft_window::Type window_type_;
  uint32_t block_size_;
  uint8_t channel_count_;

  using InputBuffer = MultichannelOverlapRingBuffer;
  using InputBufferPtr = std::shared_ptr<InputBuffer>;
  std::vector<InputBufferPtr> input_buffers_;
  using OutputBuffer = MultichannelRingBuffer;
  using OutputBufferPtr = std::shared_ptr<OutputBuffer>;
  std::vector<OutputBufferPtr> output_buffers_;

  std::vector<std::shared_ptr<Analyzer>> analyzers_;
  std::vector<std::shared_ptr<Analyzer>> synthesizers_;

  class Impl;
  std::shared_ptr<Impl> impl_;
};

} // namespace rtff

#endif // RTFF_MIXING_FILTER_H_
